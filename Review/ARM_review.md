## 嵌入式系统基础与实践复习大纲

##### 1. 什么是嵌入式系统？
课本p9
&emsp;&emsp;由于嵌入式技术及其应用领域的不断发展，行业内对于嵌入式系统并没有一个统一的定义，国外把嵌入式系统定义为：嵌入式系统是控制、监视或辅助操作设备、机器和车间运行的装置。可以看出，嵌入式系统之所以称为“系统”，是因为该系统中不仅有被控对象，而且包括控制系统所用到的硬件和软件。
&emsp;&emsp;国内行业普遍认同的定义为：以应用为中心、以计算机技术为基础，软、硬件可剪裁，适合应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统，实现对其他设备的控制、监视或管理等功能。也就是说，嵌入式系统的开发是基于功能与性能裁剪的，不需要或用不到的功能可不作考虑，功耗和体积也是嵌入式系统要考虑的主要问题。

##### 2. 嵌入式系统与通用计算机系统的区别？
课本p10
&emsp;&emsp;微型计算机的发展取决于微处理器的发展，在微处理器基础上发展的通用微处理器(PC)和嵌入式微处理器，形成了微型计算机的两大分支，即通用计算机系统和嵌入式系统。从基本架构上来看，两者没有本质区别，都是由CPU、存储器、输入输出设备组成的，但就应用场合而言，两者的区别相当明显，通用计算机系统可以自主安装和运行各种功能的软件，其适用性强、可扩展性强，功能强大；嵌入式系统通常是专用的，其程序是固化在芯片上的，用户不能更改，专用性强。随着物联网的发展，嵌入式计算机的数量已远远超过了通用计算机的数量。 
&emsp;&emsp;通用计算机系统与嵌入式系统的比较如表1-1所示，通用计算机系统依据高速、海量数据的并行运算从计算平台发展到了互联网，而嵌入式系统则依据低功耗和便携方式从终端硬件延伸到了物联网。
##### 3. 嵌入式系统的案例分析，从系统功能、系统组成框架等方面分析，如何设计智能家居、智能手环等嵌入式系统。
课本p6-7
**答:** 功能概述：一个相对完善的智能家居监控系统主要包括以下四个功能:
1. 家庭安全监护。家居中的门窗、燃气、火灾等异常状况，应及时将相应警报信息发送到移动终端，帮助用户及时了解家中的安全状况。
2. 家庭环境优化服务。控制家中的温度、湿度等，智能启动加湿器、空调，对家居环境进行智能调节室温和空气湿度，给用户一个舒适的生活环境。
3. 家庭能源管理。远程管理电源、用电设备及异常，能够智能降低功耗，监控用电设备安全。
4. 家居智能控制服务。对家中的所有家电，可通过移动终端实现远程或本地的开关控制。

系统硬件结构框图如下图所示。
<img src="figure\sys_chart.png" width="70%" alt="智能家居监控系统硬件结构框图" align=center />

各功能模块概述：
1. 通信电路设计。短信监控功能通过 GPRS 模块对短信进行操作实现，采用 AT 指令进行通信操作。本系统中采用基于 USB 的通信模块SIM908，通过 STM32 的串口进行连接。
2. 显示模块电路。液晶显示屏 TFT-LCD 具有驱动电压低、功耗小、反应速度快、显示画面质量好等优点，本系统采用 LCD 作为显示设备。LCD 的端口包括数据端口和控制端口，其中数据端口与主控芯片的 PB0-PB5 进行连接，控制端口与主控芯片的 PC6-PC9 连接。
3. 数据采集模块电路。温度采集采用数字温度传感器 DS18B20。功率采集电路主要由电流检测电路、电压检测电路、电能计量芯片 ADE7755 及其外围电路组成。家电开断控制电路采用三极管驱动继电器来实现家用电器供电控制。
##### 4. 冯诺依曼结构与哈佛结构特点与区别？
课本p23-24
&emsp;&emsp;冯·诺依曼结构也称普林斯顿结构，是一种指令和数据采用二进制表示，且存储在同一个存储器中，并经同一条总线传输的存储器结构，冯·诺依曼结构中指令地址和数据地址指向同一个存储器的不同物理位置，两者统一编址且宽度相同。
&emsp;&emsp;哈佛结构是一种将程序指令和数据分开存储的存储器结构，目的是为了打破程序访问时的瓶颈。指令存储器和数据存储器独立编址、独立访问，数据和指令分别存储在两个独立的存储器中，并且使用两条独立的总线分别与 CPU 进行信息交换，数据和指令的存储可以同时进行，执行时可以预先读取下一条指令，容易实现指令流水。
&emsp;&emsp;冯·诺依曼结构多用于桌面处理器和移动处理器，哈佛结构主要用于嵌入式系统领域。与冯·诺依曼结构处理器比较，哈佛结构处理器有以下明显的特点。
1. 程序存储和数据存储相互独立，使用两个独立的存储器模块，分别存储指令和数据，每个存储
模块都不允许指令和数据并存。
2. 使用独立的两条总线，分别作为 CPU 与每个存储器之间的专用通信路径，而这两条总线之间毫
无关联。
3. CPU 采用不同的指令来访问程序和数据。

##### 5. Cortex-M3 微处理器主要由哪些部分组成？
课本p33-34
&emsp;&emsp;Cortex-M3 是基于 ARMv7-M 体系结构设计的 32 位处理器内核，Cortex-M3 微处理器主要由两大部分组成：Cortex-M3 内核和调试系统。Cortex-M3 内核主要包括以下 5 部分：
1. 中央处理器核心（Cortex-M3 Core）
2. 嵌套向量中断控制器（NVIC）
3. 系统时钟（SYSTICK）
4. 存储器保护单元（MPU）
5. 总线矩阵（AHB 互连网络）

&emsp;&emsp;调试系统主要用于调试和测试，其主要包括：串行线/串口 JTAG 调试端口（SW-DP/J.TAG-DP）、基于 AHB 总线的通用调试接口（AHB-AP）、嵌入式跟踪单元（ETM）和数据观察点触发器（DWT）等，其中两个调试端口提供对系统中（包括处理器寄存器）所有寄存器和存储器的调试访问。
##### 6. ARM 内存中数据两种存储模式？（大端格式、小端格式）举例说明。
课本p24-25
&emsp;&emsp;现有一个 32 位的数据 0x12345678，存放在内存地址为 0x4000～0x4003 处，若按小端模式进行存放，则其最低字节数据 0x78 存放在内存地址0x4000处；若以大端模式存储，则最高字节数据0x12 存放在内存0x4000处。
##### 7. CM3 三级流水线分别是？每一级功能？
课本p27-28
&emsp;&emsp;取指令、译码、执行。
&emsp;&emsp;取指令：将指令从存储器中取出。
&emsp;&emsp;译码：对所取指令进行翻译，分析该指令需要执行何种操作。
&emsp;&emsp;执行：执行指令，完成指令所规定的任务。
##### 8. 流水线性能通常用哪三项指标衡量？如何计算吞吐率，举例说明？
详见课本p28
&emsp;&emsp;吞吐率、加速比、效率。
吞吐率=指令条数/指令流水线所需时间。
##### 9. CM3 核的通用寄存器、低组寄存器、高组寄存器分别有哪些?字长？
课本p37-38
&emsp;&emsp;CM3 核的通用寄存器包括 13 个 32 位的通用寄存器 R0～R12，低组寄存器R0～R7，高组寄存器R8～R12。
##### 10. 程序状态寄存器 APSR、控制寄存器 CONTROL、PRIMASK、FAULTMASK、BASEPRI 寄存器的作用？
详见课本p38
##### 11. CM3 核的存储器映射分为哪 6 个区域？区域大小？每个区域的地址范围？
详见课本p39-40
##### 12. NVIC 全称是？作用？
详见课本p33 **2.3** 1.(2)、p41-42
Nested Vectored Interrupt Controller，嵌套向量中断控制器
##### 13. CM3 进入中断或异常时，经历哪 3 步？每一步具体操作是？如何从中断返回过程？
前两问详见课本p42

当异常处理结束后，硬件将 `PC=EXC_RETURN`，触发异常返回机制:
- 恢复先前压入栈中的寄存器，堆栈指针的值也改回先前的值
- 更新NVIC寄存器：活动位被硬件清除，对于外部中断，倘若中断输入再次被置为有效，悬起位也将再次置位。
##### 14. STM32 的 HSE、HSI、PLL、LSE、LSI 分别是？系统时钟 SYSCLK、HCLK、PCLK1、PCLK2 分别是？
详见课本p48-49
- **HSI**：High Speed Internal，高速内部时钟，由内部 8MHz 的 RC 振荡器生成，可作为系统时钟或经 2分频后作为 PLL 输入。特点：时钟频率精度差，不稳定。
- **HSE**：High Speed External，高速外部时钟，可外接一个外部时钟源，或者通过 OSC_IN 和 OSC_OUT 引脚外接晶振，允许外接的晶振频率范围为 4～16MHz，通常使用 8MHz。特点：精度高，稳定。
- **LSI**：Low Speed Internal，低速内部时钟，由内部 RC 振荡器产生，频率约 40kHz，主要为独立看门狗（IWDG）和自动唤醒单元提供时钟。
- **LSE**：Low Speed External，低速外部时钟，通过 OSC32_IN 和 OSC32_OUT 引脚外接频率为 32.768kHz 的晶振，为 RTC（Real-Time Clock，实时时钟部件）提供低速高精度的时钟源。
- **PLL**：Phase Locked Loop，锁相环，是一种反馈控制电路，用于外部输入时钟信号与内部振荡信号的同步（频率和相位相同），以确保输出频率的稳定。另一方面，也可用于倍频 HSI 或 HSE，其时钟输入源可选择为 HSI/2、HSI 或者 HSE，倍频可选择为 2～16 倍，但其输出频率最大不得超过 72MHz。

- **SYSCLK**
系统时钟SYSCLK最大频率为72MHz，它是供STM32中绝大部分部件工作的时钟源。系统时钟可由PLL、HSI或者HSE提供输出，并且它通过AHB分频器分频后送给各模块使用。


##### 15. STM32F103 支持的中断数量，优先级数量？优先级控制位分组情况？优先级管理原则？
60个中断，16个优先级
剩余详见课本p47
##### 16. 根据命名原则，芯片 STM32F103ZET6 中各符号代表的含义？
课本p51
&emsp;&emsp;STM32 代表 ARM Cortex-M3 内核的 32 位微控制器，ST 为意法半导体，M 为微控制器的缩写，32 代表是 32 位的芯片，F 代表芯片的系列为基础级，103 为增强型系列为主流入门级，Z 表示此芯片有 144 管脚，E 表示具有 512KB 的 Flash，T 表示此芯片采用 LQFP 封装，6 表示芯片工作温度范围为 40～+85℃。

##### 17. 简述 STM32 微控制器三种开发模式？
课本p55-56
ST 公司为 STM32 提供了以下三种开发模式。
1. 寄存器开发方式。
2. 标准外设库开发方式。
3. HAL（Hardware Abstraction Layer，硬件抽象层）库开发方式。

&emsp;&emsp;标准外设库（Standard Peripherals Library）简称标准库，其开发方式是将底层寄存器的操作进行了统一封装，包括所有标准器件外设的驱动器，采用 C 语言实现，开发人员只需要熟悉并调用相应的 API （Application Programming Interface，应用程序编程接口）函数，即可实现对相关外设的驱动操作。由于标准库只是将一些基本的寄存器操作封装成了 C 函数，因此使用标准库可以很简单地跟踪到底层寄存器，这对学习和掌握硬件底层相关的内容十分有利。需要注意的是，标准库是针对某一系列的芯片开发的，其跨平台移植性很差。
&emsp;&emsp;HAL 库开发是与 STM32CubeMX 软件（STM32CubeMX 是一个配置 STM32 代码的工具）配套使用的，它把底层硬件相关的内容封装起来并进行抽象，通过图形化的操作方式自动生成相关外设的驱动代码，简单易用，但若要从 HAL 库跟踪代码并理解其架构却很难。
&emsp;&emsp;以上三种开发方式各有利弊，寄存器开发需要对底层寄存器十分熟悉，开发过程慢，但代码量小，代码执行效率高。基于库的开发方式已成为当今嵌入式开发的主流开发方式，也是各大半导体公司和嵌入式行业大力推崇的一种方式。

##### 18. STM32F103 系列产品中的高密度、中密度、低密度是如何划分的？
课本p51
&emsp;&emsp;STM32F1 系列产品中，每个系列又有多种型号供用户选择，各个子系列按闪存容量的大小又分为小容量、中容量和大容量产品。
1. 低密度（LD，Low-Density）：闪存容量为 16～32KB 的小容量产品。
2. 中密度（MD，Medium-Density）：闪存容量为 64～128KB 的中容量产品。
3. 高密度（HD，High-Density）：闪存容量为 256～512KB 的大容量产品。
4. 超密度（XL，XL-Density）：闪存容量为 768KB～1MB 的大容量产品。

##### 19. 简述在 Keil5 环境下，新建基于 STM32F103C8T6 微控制器工程的步骤。
详见课本p73-86
##### 20.简述在STM32CUBEIDE环境下，新建基于STM32F103C8T6为控制器工程的步骤。
详见课本p90-93
##### 21. STM32 复位电路由哪几种方式？
课本p102
STM32 复位电路有以下两种复位方式。
1. 上电复位：在上电瞬间，由于电容两端的电压不能突变，因此 RESET 出现短暂低电平，芯片自动复位，然后电容充电，充电时间由电阻和电容共同决定，系统完成复位，之后，单片机开始正常工作，电容相当于断路，复位端 RESET 一直为高电平。
2. 手动复位：按键 S1 按下时，RESET 与地连通，产生低电平，实现复位。
##### 22. STM32 三种不同启动模式？如何配置？
详见课本p103-104
##### 23. HAL 库的回调函数形式和作用？
回调函数原型如下：
```c
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);
```
&emsp;&emsp;该回调函数的函数体基本上是空的，其默认实现声明为`__weak` 属性，`weak` 关键字表示弱声明，其作用在于一旦声明了用户自己编写的同名函数，链接器就会替换掉原来用`__weak` 声明的函数，链接用户编写的同名函数。所以，STM32 的 HAL 库的回调函数的函数体需要用户自己编写，其实质是通过中断处理函数，如下所示，调用回调函数来实现中断服务功能。
```c
void HAL_GPIO_EXTI_IRQHandler (uint16_t GPIO_Pin)
```


##### 24. STM32 开发中，使用了英文缩写，解释下列英文缩写的含义。RCC RTC EXTI PWM PLL NVIC ISP UART SPI AFIO IRQ BKP APB
1. RCC：Reset and Clock Control，即复位和时钟控制。
2. RTC ：Real Time Clock，实时时钟。
3. EXTI：External Interrupt/Event Controller，外部中断/事件控制器
4. PWM：Pulse Width Modulation，简称脉宽调制
5. PLL ：Phase Locked Loop，锁相环
6. NVIC ：Nested Vectored Interrupt Controller，嵌套向量中断控制器
7. ISP ：In-System Programming，在系统可编程（在线编程）
8. UART：Universal Asynchronous Receiver/Transmitter，通用异步收发器
9. SPI：Serial Peripheral Interface, 串行外设接口
10. AFIO ：Alternate Function Input/Output，复用 I/O 端口
11. IRQ ：Interrupt ReQuest，中断请求
12. BKP ：BACKUP，备份寄存器
13. APB：Advanced Peripheral Bus，先进外设总线

##### 25. STM32 单片机最小系统有哪几部分组成？画出最小系统电路图。
&emsp;&emsp;最小系统也称为单片机最小应用系统，是指用最少的元件组成单片机可以工作的系统。对 STM32微控制器来说，典型的最小系统一般包括电源电路、晶振电路、复位电路和程序下载电路，往往还包含LED 指示电路。
最小系统电路图见课本p99 图 4-1 电源电路、p101 图4-4 晶振电路、p102 图4-6 复位电路、p104 启动选择电路

调试和下载电路如下图所示。
<img src="https://pic3.zhimg.com/80/v2-b1163824424f0786123154cfc24ac982_1440w.webp" width="50%" >

##### 26. GPIO 模式有哪几种？速度选择有哪几种？
详见课本p145 5.2.3，p148 5.2.4
##### 27. GPIO 通用输出包括哪两种？如何选择输出模式？复用输出包括？
&emsp;&emsp;推挽输出模式和开漏输出模式。
&emsp;&emsp;在推挽输出模式下，当 I/O 引脚输出高电平时，P-MOS 导通。当 I/O 引脚输出低电平时，N-MOS 导通。这样两个 MOS 管轮流导通，其负载能力和开关速度得到提高。使用推挽输出模式的目的是增大输出电流，即提高输出引脚的驱动能力，提高电路的负载能力和开关的速度。
&emsp;&emsp;开漏输出模式下，I/O 引脚只能输出低电平，即当输出寄存器输出为低电平时，N-MOS 导通；当输出寄存器输出为高电平时，N-MOS 截止，此时无论写入什么数据，P-MOS 都截止，相当于断开了 P-MOS 管，输出为高阻状态。若要输出高电平，则需外接电阻，所接的电阻称为上拉电阻，此时输出电平取决于该引脚外接的上拉电阻及外部电源电压情况。因此，开漏输出模式可以用来匹配电平，适用于电平不匹配的场合。

复用推挽输出、复用开漏输出
##### 28. GPIO 应用实例：
1.  按键控制 LED 亮与灭（按下亮，释放熄灭）或控制制蜂鸣器响（按下响，松开不响）；

`key.c`
```c
#include "key.h"
//按键初始化函数
void KEY_Init(void) //IO 初始化
{ 
    GPIO_InitTypeDef GPIO_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE); //使能 PORTE 时钟
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//GPIOE.2
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //设置成上拉输入
    GPIO_Init(GPIOE, &GPIO_InitStructure); //初始化 GPIOE2
}
//按键处理函数
//返回按键值
u8 KEY_Scan(void)
{
    static u8 key_up=1; //按键按松开标志
    if(key_up&&(KEY2==0))
    {
        delay_ms(10); //去抖动
        key_up=0;
        if(KEY2==0)
            return KEY2_PRES;
    }
    else if(KEY2==1)
        key_up=1; 
    return 0; // 无按键按下
}
```

`key.h`
```c
#ifndef __KEY_H
#define __KEY_H
#include "stm32f10x.h"
#include "delay.h" 

#define KEY2 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_2)//读取按键 2 
#define KEY2_PRES 3 //KEY2 按下

void KEY_Init(void); //IO 初始化
u8 KEY_Scan(void); //按键扫描函数
#endif
```

`led.c`
```c
#include "led.h"
//初始化 PB5 为输出口.并使能时钟 
//LED IO 初始化
void LED_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //使能 PB 端口时钟
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //LED0-->PB.5 推挽输出
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    GPIO_SetBits(GPIOB,GPIO_Pin_5); //PB.5 输出高
}
```
`led.h`
```c
#ifndef __LED_H
#define __LED_H
#include "stm32f10x.h"
void LED_Init(void);//初始化 
#endif
```

`main.c`
```c
#include "led.h"
#include "delay.h"
#include "key.h"
#include "stm32f10x.h"

int main(void)
{
    u8 key;
    delay_init(); //延时函数初始化 
    LED_Init(); //LED 端口初始化
    KEY_Init(); //初始化与按键连接的硬件接口
    u8 flag=0;    
    while(1)
    {
        key =KEY_Scan(); //得到键值
        if(key)
        { 
            switch(t)
            { 
                case KEY2_PRES: //控制 LED0 翻转
                    flag=!flag;
                break;
            }
        }
        else 
            delay_ms(10); 
        if(flag)
            GPIO_ResetBits(GPIOB,GPIO_Pin_5); //LED0 点亮
        else
            GPIO_SetBits(GPIOB,GPIO_Pin_5); //LED0 熄灭
    }
}
```

2.  流水灯或跑马灯类应用

`led.c`
```c
#include "led.h"
//初始化 PB5 为输出口.并使能时钟
//LED IO 初始化
void LED_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE, ENABLE); //使能 PB,PE 端口时钟
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //LED0-->PB.5 推挽输出
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //LED1-->PE.5 推挽输出
    GPIO_Init(GPIOE, &GPIO_InitStructure);
    GPIO_SetBits(GPIOB,GPIO_Pin_5); //PB.5 输出高
    GPIO_SetBits(GPIOE,GPIO_Pin_5); //PE.5 输出高
}
```

`main.c`
```c
#include "led.h"
#include "delay.h"
#include "stm32f10x.h"

int main(void)
{
    delay_init(); //延时函数初始化 
    LED_Init(); //LED 端口初始化
    while(1)
    {
        GPIO_ResetBits(GPIOB,GPIO_Pin_5); //LED0 点亮
        delay_ms(500);
        GPIO_ResetBits(GPIOE,GPIO_Pin_5); //LED1 点亮
        delay_ms(500);
        GPIO_SetBits(GPIOB,GPIO_Pin_5); //LED0 熄灭
        delay_ms(500);
        GPIO_SetBits(GPIOE,GPIO_Pin_5); //LED1 熄灭
    }
}
```

##### 29. 简述 STM32 的中断和异常？为什么使用中断？简述中断处理流程？
课本p183 6.2
&emsp;&emsp;单片机的中断有两类：外部中断和内部中断。由外部原因或事件导致的中断称为外部中断，即可以人工控制的中断；由自身因素导致的中断称为内部中断（Cortex-M3 称为异常）。STM32 通过其内部的 NVIC（Nested Vectored Interrupt Controller，嵌套向量中断控制器）来进行管理和配置，实现中断通道的设置、优先级分配及中断使能等功能。STM32F10x 系列产品有 84 个中断通道，包括 16 个内核中断和 68 个可屏蔽中断，具体到 STM32F103系列芯片只有 60 个可屏蔽中断，STM32F107 系列有 68 个可屏蔽中断。

详见课本p181 6.1.2 为什么使用中断？

课本p181 6.1.3
&emsp;&emsp;一个完整的中断处理过程分为 4 个步骤：中断请求、中断响应、中断服务和中断返回。
##### 30. STM32 中断优先级有几级？优先级原则是什么？给出几个中断源的优先级，判断它们的响应次序
16级，
详见课本p190 例如代码框下方
##### 31. EXTI 应用实例：通过按键触发外部中断，控制 LED 亮灭等；
详见课本p198-200
##### 32. USART 异步通信的帧格式？每部分的作用。
课本p212 7.2.1
异步串行通信的数据帧由起始位、数据位、校验位、停止位 4 部分组成。
- 起始位：占一位，位于数据帧的开头，其值为 0，即以逻辑 0 表示传输数据的开始。
- 数据位：要发送的数据，数据长度可以是 5 位、6 位、7 位或 8 位，低位在前，高位在后，数据通常用 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）码表示。传输数据时先传送字符的低位，后传送字符的高位，即采用小端方式由最低有效位（Least Significant Bit，LSB）到最高有效位（Most Significant Bit，MSB）一位一位地传输。
- 校验位：占一位，用于检测数据是否有效，该位为可选项。若校验位为 0，则表示不对数据进行校验。若校验位为“1”，则对数据位进行奇校验或偶校验。设置奇偶校验位是为了提高数据传输的准确率。
- 停止位：一帧传送结束的标志，根据实际情况而定，可以是 1 位、1.5 位或 2 位。
- 空闲位：数据传输完毕，数据帧之间用 1 表示空闲位，即用 1 表示当前线路上没有数据传输。

##### 33. 什么是串行通信？并行通信？什么是同步通信？异步通信？什么是单工、半双工、全双工？
详见课本p209-211 7.1
##### 34. RS232 电平与 TTL 电平有什么区别？STM32 微控制器串口要使用 232 电平通信，需要如何处理？
详见课本p214
##### 35. STM32F1 系列单片机有几个串口？
课本p215 7.3
3个USART，2个UART
#### 36. USART 应用举例：
1. 发送数据类型：buf[100]有 100 个数据，通过串口发送出去。给定波特率、数据格式等要求。编写初始化程序、发送程序。
2. 接收数据类型：中断方式或查询方式接收 100 个数据，并保存在 buf[100]中。给定串口相关参数。编写初始化程序、接收程序。
##### 37. 什么是 DMA 传输？简述 DMA 传输过程？DMA 在什么情况下可产生中断？ DMA单次传输和循环传输？什么是地址自增和地址固定方式？DMA 优先级情况。
前两问见课本p247-248 8.1
p250 8.2.3 DMA中断请求

DMA传输方式
- DMA Mode Normal，单次传输模式
当一次DMA数据传输完后，停止DMA传送，也就是只传输一次
- DMA Mode Circular ，循环传输模式
当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。 也就是多次传输模式

地址自增和地址固定
- 地址自增：下一个要传输的地址将是前一个地址加上增量值
- 地址固定：每次传输后，地址不变

p250 8.2.2 DMA优先权
##### 38. DMA 应用：缓冲区里存放一批数据，采用 DMA 方式通过串口发送出去。
详见课本p255-258
##### 39. STM32 定时器功能分为哪 6 类？普通定时器、通用、高级定时器的主要区别？
详见课本p267 
p269 表9-1
##### 40. 看门狗的作用？包括哪两种？
详见课本p268 2.看门狗定时器
##### 41. 什么是 PWM?STM32F1 有哪两种 PWM 模式？有什么区别？
详见课本p289 
- PWM 模式 1：在向上计数时，一旦TIMx_CNT<TIMx_CCR1时通道1为有效电平，否则为无效电平；在向下计数时，一旦TIMx_CNT>TIMx_CCR1时通道1为无效电平(OC1REF=O)，否则为有效电平(OC1REF=1)。
- PWM模式2：在向上计数时，一旦TIMx_CNT<TIMx_CCR1时通道1为无效电平，否则为有效电平；在向下计数时，一旦TIMx_CNT>TIMX_CCR1时通道1为有效电平，否则为无效电平。
##### 42. 什么是输入捕获？什么是输出比较？
&emsp;&emsp;输入捕获，通过检测 TIMx_CHx 上的边沿信号，在边沿信号发生跳变（比如上升沿/下降沿）的时候，将当前定时器的值（TIMx_CNT）存放到对应的通道的捕获/比较寄存器（TIMx_CCRx）里面，完成一次捕获。可测量PWM波形的频率、占空比。
&emsp;&emsp;输出比较，通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形 。
##### 43. 基本定时类：定时器周期定时 200ms，在中断程序中完成某一操作，LED 灯闪烁。掌握定时器初始化流程、中断程序写法。
详见课本p276-279
#### 44. PWM 类：给定 PWM 信号要求，利用定时器的 PWM 功能产生。比如：输出 2KHz，占空比 50%的方波信号。
##### 45. 简述 ADC 的转化过程？解释 ADC 转换的分辨率、转换时间和转换速率、转换误差。
详见课本p306-308
&emsp;&emsp;A/D 转换过程一般包括采样、保持、量化和编码 4 个步骤。
&emsp;&emsp;ADC 的技术参数主要从转换精度和转换速度两方面考虑，一般用分辨率和转换误差来描述转换精度，用转换时间或转换速率描述转换速度。
##### 46. STM32F1 有几个 ADC？位数是？ADC1 的通道数？ADC 有几种转换方式？
课本p308 10.2
三个12位ADC，ADC1总共有18个通道
&emsp;&emsp;STM32 的 ADC 有 16 个模拟输入通道，ADCx_IN0～ADCx_IN15 为 ADC 的输入信号通道，即为 ADC 的输入 GPIO 引脚，ADC 的 GPIO 引脚均为复用功能，使用时需将其配置为模拟输入模式。
&emsp;&emsp;ADC1 还有两个内部通道：温度传感器通道和 VREFINT，分别用来测量芯片内部的温度和内部参考电压。温度传感器连接到 ADC1_IN16 通道，内部参考电压 VREFINT 连接到 ADC1_IN17 通道。
&emsp;&emsp;STM32 设计了按组进行转换的模式，可以由程序设置实现对多个模拟通道自动地进行逐个采样转换，STM32 分为两种组转换模式：规则组和注入组。

课本p313 10.2.6
&emsp;&emsp;ADC 的转换模式主要有以下 4 种。
1. 单次模式
单次转换模式下，ADC 只执行一次转换。
2. 连续模式
连续转换模式下，当前 ADC 转换结束后就会立即启动下一个转换。
3. 扫描模式
扫描模式用来扫描一组模拟通道，这组通道可以来规则通道组也可以来自注入通道组。开启扫描模式后，ADC 将扫描被选中通道组的所有通道，若将此时的转换模式设置为单次转换，则在扫描完本组所有通道后，ADC 自动停止；若将转换模式设置为连续模式，则在扫描完本组所有通道后，再从第一个通道继续扫描。
4. 间断模式
间断模式用于多个通道的规则通道组和注入通道组。

##### 47. STM32F103 系列微控制器的 ADC 最短转换时间是？如何得出的？
课本312 10.2.4
&emsp;&emsp;STM32 芯片参考手册中规定：ADC 的时钟频率不能超过 14MHz，该频率由 PCLK2 经分频产生。由 STM32 的时钟结构可知，ADC 的时钟（ADCCLK）是由 APB2（PCLK2）经 ADC 预分频器分频得到的，分频值可设置为 2、4、6 或 8。
&emsp;&emsp;A/D 转换在采样时信号需保持一定的时间，以保证 A/D 转换的正确实现。STM32 的 ADC 每条通道的采样时间都可以进行选择，采样时间可选择为采样周期的 1.5 倍、7.5 倍、13.5 倍、28.5 倍、41.5 倍、55.5 倍、71.5 倍或 239.5 倍。
&emsp;&emsp;ADC 总的转换时间=采样时间+12.5 个周期
&emsp;&emsp;由于 ADC 的时钟 ADCCLK 最大不能超过 14MHz，因此 STM32F103 系列微控制器的 ADC 最短转换时间为 1us。采样时间越长，转换结果越稳定。

##### 48. ADC 应用：ADC1 的通道 1 采样外部电位器的电压，得到数字量转成对应的电压值。
详见课本p320-323
##### 49. CM3 核有几种低功耗模式？如何从这些低功耗模式中唤醒？
STM32 的低功耗模式有 3 种：
1. 睡眠模式（CM3 内核停止，外设仍然运行）
2. 停止模式（所有时钟都停止）
3. 待机模式（1.8V 内核电源关闭）

唤醒见表格唤醒一栏
<img src="figure\wk_up.png" width="70%" >